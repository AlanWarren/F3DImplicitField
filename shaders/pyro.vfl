/****************************************************************************
          File:  pyro.vfl
       Created:  Feb 14, 2009
   Description:  (VEX) Smoke and fire volume shader v1.9

*****************************************************************************/

#include <blackbody.h>

// -------------------------------------------------------------------------------
// Functional blocks (PRE = parameter prefix, POST = postfix)
// -------------------------------------------------------------------------------

// Float Ramp
//---------------------------------------
#define RAMP_PARMSDFLT(PRE,name,POST) \
   string  PRE##name##w##POST##b[] = {"linear", "linear"} ; \
   float   PRE##name##w##POST##k[] = {0,1};   \
   float   PRE##name##w##POST##v[] = {0,1}

#define RAMP_PARMS(PRE,name,POST)    \
   string  PRE##name##w##POST##b[] ; \
   float   PRE##name##w##POST##k[] ; \
   float   PRE##name##w##POST##v[]

#define RAMP_ARGS(PRE,name,POST)   \
           PRE##name##w##POST##b , \
           PRE##name##w##POST##k , \
           PRE##name##w##POST##v

// Color Ramp
//---------------------------------------
#define RAMPC_PARMSDFLT(PRE,name,POST) \
   string  PRE##name##w##POST##b[] = {"linear", "linear"} ; \
   float   PRE##name##w##POST##k[] = {0,1};   \
   vector  PRE##name##w##POST##v[] = {0,1}

#define RAMPC_PARMS(PRE,name,POST)    \
   string  PRE##name##w##POST##b[] ; \
   float   PRE##name##w##POST##k[] ; \
   vector  PRE##name##w##POST##v[]

#define RAMPC_ARGS(PRE,name,POST)   \
           PRE##name##w##POST##b , \
           PRE##name##w##POST##k , \
           PRE##name##w##POST##v



// Field shaping parameters
//---------------------------------------
#define FSHAPE_PARMSDFLT(PRE,POST)       \
   int     PRE##tlabel##POST    = 0    ; \
   string  PRE##label##POST     = ""; \
   string  PRE##comment##POST   = ""; \
   int     PRE##enable##POST    = 1    ; \
   string  PRE##field##POST     = "density"; \
   int     PRE##tsharp##POST    = 0    ; \
   float   PRE##sharpe##POST    = 0.01 ; \
   float   PRE##sharpk##POST    = 4    ; \
   int     PRE##tsoft##POST     = 0    ; \
   float   PRE##softe##POST     = 0.8  ; \
   float   PRE##softk##POST     = 1    ; \
   int     PRE##trng##POST      = 0    ; \
   float   PRE##rngsl##POST     = 0    ; \
   float   PRE##rngsh##POST     = 1    ; \
   float   PRE##rngtl##POST     = 0    ; \
   float   PRE##rngth##POST     = 1    ; \
   RAMP_PARMSDFLT(PRE,rng,POST)

#define FSHAPE_PARMS(PRE,POST)    \
   int     PRE##tlabel##POST    ; \
   string  PRE##label##POST     ; \
   string  PRE##comment##POST   ; \
   int     PRE##enable##POST    ; \
   string  PRE##field##POST     ; \
   int     PRE##tsharp##POST    ; \
   float   PRE##sharpe##POST    ; \
   float   PRE##sharpk##POST    ; \
   int     PRE##tsoft##POST     ; \
   float   PRE##softe##POST     ; \
   float   PRE##softk##POST     ; \
   int     PRE##trng##POST      ; \
   float   PRE##rngsl##POST     ; \
   float   PRE##rngsh##POST     ; \
   float   PRE##rngtl##POST     ; \
   float   PRE##rngth##POST     ; \
   RAMP_PARMS(PRE,rng,POST)

#define FSHAPE_ARGS(PRE,POST)  \
           PRE##tlabel##POST , \
           PRE##label##POST  , \
           PRE##comment##POST, \
           PRE##enable##POST , \
           PRE##field##POST  , \
           PRE##tsharp##POST , \
           PRE##sharpe##POST , \
           PRE##sharpk##POST , \
           PRE##tsoft##POST  , \
           PRE##softe##POST  , \
           PRE##softk##POST  , \
           PRE##trng##POST   , \
           PRE##rngsl##POST  , \
           PRE##rngsh##POST  , \
           PRE##rngtl##POST  , \
           PRE##rngth##POST  , \
           RAMP_ARGS(PRE,rng,POST)

// Noise parameters
//---------------------------------------
#define NOISE_PARMSDFLT(PRE,POST)          \
   int     PRE##enable##POST    = 1;       \
   string  PRE##field##POST     = "none";  \
   float   PRE##rngsl##POST     = 0;       \
   float   PRE##rngsh##POST     = 0.3;     \
   RAMP_PARMSDFLT(PRE,rng,POST);           \
   float   PRE##amp##POST       = 1;       \
   string  PRE##ampm##POST      = "none";  \
   int     PRE##is4d##POST      = 0;       \
   vector4 PRE##freq##POST      = 1;       \
   vector4 PRE##off##POST       = 0;       \
   float   PRE##fw##POST        = 1;       \
   float   PRE##oct##POST       = 8;       \
   string  PRE##octm##POST      = "none";  \
   float   PRE##lac##POST       = 2.01234; \
   string  PRE##lacm##POST      = "none";  \
   float   PRE##gain##POST      = 0.5;     \
   string  PRE##gainm##POST     = "none";  \
   float   PRE##expon##POST     = 1;       \
   string  PRE##exponm##POST    = "none";  \
   float   PRE##rngol##POST     = 0;       \
   float   PRE##rngoh##POST     = 1

#define NOISE_PARMS(PRE,POST)  \
   int     PRE##enable##POST ; \
   string  PRE##field##POST  ; \
   float   PRE##rngsl##POST  ; \
   float   PRE##rngsh##POST  ; \
   RAMP_PARMS(PRE,rng,POST)  ; \
   float   PRE##amp##POST    ; \
   string  PRE##ampm##POST   ; \
   int     PRE##is4d##POST   ; \
   vector4 PRE##freq##POST   ; \
   vector4 PRE##off##POST    ; \
   float   PRE##fw##POST     ; \
   float   PRE##oct##POST    ; \
   string  PRE##octm##POST   ; \
   float   PRE##lac##POST    ; \
   string  PRE##lacm##POST   ; \
   float   PRE##gain##POST   ; \
   string  PRE##gainm##POST  ; \
   float   PRE##expon##POST  ; \
   string  PRE##exponm##POST ; \
   float   PRE##rngol##POST  ; \
   float   PRE##rngoh##POST

#define NOISE_ARGS(PRE,POST) \
   PRE##enable##POST  ,      \
   PRE##field##POST   ,      \
   PRE##rngsl##POST   ,      \
   PRE##rngsh##POST   ,      \
   RAMP_ARGS(PRE,rng,POST),  \
   PRE##amp##POST     ,      \
   PRE##ampm##POST    ,      \
   PRE##is4d##POST    ,      \
   PRE##freq##POST    ,      \
   PRE##off##POST     ,      \
   PRE##fw##POST      ,      \
   PRE##oct##POST     ,      \
   PRE##octm##POST    ,      \
   PRE##lac##POST     ,      \
   PRE##lacm##POST    ,      \
   PRE##gain##POST    ,      \
   PRE##gainm##POST   ,      \
   PRE##expon##POST   ,      \
   PRE##exponm##POST  ,      \
   PRE##rngol##POST   ,      \
   PRE##rngoh##POST

#define NOISE_MODS(PRE,POST) \
   PRE##ampm##POST    ,      \
   PRE##octm##POST    ,      \
   PRE##lacm##POST    ,      \
   PRE##gainm##POST   ,      \
   PRE##exponm##POST


// -------------------------------------------------------------------------------
// Assorted math bits
// -------------------------------------------------------------------------------
#define C_PI               3.14159265358979323846  // pi 
#define C_PI2              6.28318530717958647692       // pi*2
#define VONE               {1,1,1}
#define VZERO              {0,0,0}
#define C_RLUM             (0.2125)
#define C_GLUM             (0.7154)
#define C_BLUM             (0.0721)
#define C_1_SQRT2          0.70710678118654752440  // 1/sqrt(2)
#define C_SQRT2            1.41421356237309504880  // sqrt(2) 
#define C_1_SQRT2          0.70710678118654752440  // 1/sqrt(2) 
#define C_SQRT3            1.73205080756887729353       // sqrt(3)
#define C_1_SQRT3          0.57735026918962576451       // 1/sqrt(3)




float sign(float x) {
   return (x>0)-(x<0);
}

float modulo(float a,b) { 
   float r=a%b; return r<0 ? r+b : r; 
}
vector modulov(vector a,b) { 
   return set(modulo(a.x,b.x),
              modulo(a.y,b.y),
              modulo(a.z,b.z)); 
}

vector lerpv(vector a,b,bias) {
   return set(lerp(a.x,b.x,bias.x),
              lerp(a.y,b.y,bias.y),
              lerp(a.z,b.z,bias.z));
}

vector smoothv(vector a,b,bias) {
   return set(smooth(a.x,b.x,bias.x),
              smooth(a.y,b.y,bias.y),
              smooth(a.z,b.z,bias.z));
}

vector maxfv(float a; vector b) {
   return set ( max(a,b.x), max(a,b.y), max(a,b.z) );
}
vector maxvv(vector a,b) {
   return set ( max(a.x,b.x), max(a.y,b.y), max(a.z,b.z) );
}

vector minfv(float a; vector b) {
   return set ( min(a,b.x), min(a,b.y), min(a,b.z) );
}
vector minvv(vector a,b) {
   return set ( min(a.x,b.x), min(a.y,b.y), min(a.z,b.z) );
}

vector powfv(float b; vector e) {
   return set(pow(b,e.x), pow(b,e.y), pow(b,e.z));
}
vector powvv(vector b,e) {
   return set(pow(b.x,e.x), pow(b.y,e.y), pow(b.z,e.z));
}



// -------------------------------------------------------------------------------
// Color
// -------------------------------------------------------------------------------

// Returns the complementary rgb color to the one given
// Mostly used when converting a color to an "opacity"
vector col2opac(vector c) {
   vector h = rgbtohsv(c);
   return hsvtorgb(set(modulo(h[0]+0.5,1),h[1],h[2]));
}

// Returns the hue of the given rgb color as hue (i.e with value=1)
vector rgbhue(vector c) {
   vector h = rgbtohsv(c);
   return hsvtorgb(set(h[0],h[1],1));
}

// Saturation
vector ccSat(vector col; float sat) {
   vector C = col;
   if(sat!=1.) {
        float R,G,B; assign(R,G,B,col);
        float csat=1.0-sat;
        float x = csat*C_RLUM, Rx = R*x;
        float y = csat*C_GLUM, Gy = G*y;
        float z = csat*C_BLUM, Bz = B*z;
        C = set(
                R*(x+sat) + Gy        + Bz, 
                Rx        + G*(y+sat) + Bz, 
                Rx        + Gy        + B*(z+sat)
        );
   }
   return C;
}
        
// Hue Rotation Preserving Luminance
// Rotation is normalized, so [0,1] -> [0,360 degs]
vector ccHue(vector col; float rot) {
        vector c=col;

   if(rot!=0.) {
        vector l=set(C_RLUM,C_GLUM,C_BLUM);
   
        //set x/y rotation matrices for grey vector
        float xrs=C_1_SQRT2;
        float xrc=xrs;
        matrix mat=matrix(set(1,0,0,0, 0,xrc,xrs,0, 0,-xrs,xrc,0, 0,0,0,1));
        float yrs=-C_1_SQRT3;
        float yrc=C_SQRT2/C_SQRT3;
        mat*=matrix(set(yrc,0,-yrs,0, 0,1,0,0, yrs,0,yrc,0, 0,0,0,1));
   
        //shear space to make the luminance plane horizontal
        vector ptmp=vtransform(l,mat);  
        float dx=ptmp.x/ptmp.z;
        float dy=ptmp.y/ptmp.z;
        mat*=matrix(set(1,0,dx,0, 0,1,dy,0, 0,0,1,0, 0,0,0,1));
   
        //rotate the hue
        float angle=rot*C_PI2;
        float zrs=sin(angle);
        float zrc=cos(angle);
        mat*=matrix(set(zrc,zrs,0,0, -zrs,zrc,0,0, 0,0,1,0, 0,0,0,1));
   
        //unshear
        mat*=matrix(set(1,0,-dx,0, 0,1,-dy,0, 0,0,1,0, 0,0,0,1));
   
        //un-rotate
        mat*=matrix(set(yrc,0,yrs,0, 0,1,0,0, -yrs,0,yrc,0, 0,0,0,1));
        mat*=matrix(set(1,0,0,0, 0,xrc,-xrs,0, 0,xrs,xrc,0, 0,0,0,1));
   
        c = c*mat;
   }

   return c;

}

// Brightness
float ccBright(float col; float b) {
   return b!=1.0 ? col*b : col;
}
vector ccBrightvf(vector col; float b) {
   return b!=1.0 ? col*b : col;
}
vector ccBrightvv(vector col; vector b) {
   return b!=CONE ? col*b : col;
}


// Contrast (pivot = 1)
float ccContrast(float val, cont) {
   return max(0,((val-1.0)*cont)+1.0);
}
vector ccContrastvf(vector val; float cont) {
   return maxfv(0,((val-VONE)*cont)+VONE);
}
vector ccContrastvv(vector val, cont) {
   return maxfv(0,((val-VONE)*cont)+VONE);
}


// Gamma
float ccGamma(float val, gam) {
   return pow(val,1.0/gam);
}
vector ccGammavf(vector val; float gam) {
   return pow(val,1.0/gam);
}
vector ccGammavv(vector val, gam) {
   return powvv(val,VONE/gam);
}


// HSV Correction
vector ccHSV(vector col, hsv) {
   return ccHue(ccBrightvf(ccSat(col,hsv.y),hsv.z),hsv.x);
}


// Full CC
vector cc(vector col, c_hsv, c_contrast, c_gamma, c_tint) {
   vector C = col;
   if(c_hsv!={0,1,1})   C = ccHSV(C,c_hsv);
   if(c_contrast!=VONE) C = ccContrastvv(C,c_contrast);
   if(c_gamma!=VONE)    C = ccGammavv(C,c_gamma);
   if(c_tint!=VONE)     C *= c_tint;
   return C;
}


// Black body intensity correction against a reference output used during
// calibration.
float bbadjust (
      float tstart;  // start temperature of current output range
      float tend;    // end temperature of current output range
   )
{
   float kcurr = (blackbodytmcdf(tend)-blackbodytmcdf(tstart));
   if(tend>BB_END) kcurr += (tend-BB_END) / BB_STEP;
   return   12.0 * blackbodytmcdf(4000) / kcurr; //blackbodytmcdf(tend);
}


// -------------------------------------------------------------------------------
// Phase
// -------------------------------------------------------------------------------

// Henyey-Greenstein phase function (wi and wo point away from P)
// This normalized form integrates to 1 over the sphere and is 
// meant to be used when sampling over the whole sphere just
// adding weighted samples. For drawing importance samples, 
// use sampler_hg() instead.
float hgphase(float g; vector wi, wo) {
   float out = 1; // equal probability when g==0
   if(g!=0) {
      float gg = clamp(g,-1.+1e-6,1.-1e-6);
      float g2=gg*gg;
      out = (1. - g2) / pow(1. + g2 - (2.*gg*dot(-wi,wo)), 1.5);
   }
   return out;
}
vector hgphasev(vector g; vector wi, wo) {
   return set( hgphase(g.x,wi,wo), hgphase(g.y,wi,wo), hgphase(g.z,wi,wo));
}

// This version returns relative weights for outgoing directions.
// It's the same function as above, but normalized to the maximum
// output for a given 'g', where the maximum is:
//
// max(hgphase(g)) = (1-g^2) / (1+g^2-2*g*sign(g))^(3/2)
//
// And so this "relative weights" version is:
//
// | (1-g^2) / (1+g^2-2*g*cos(theta)) |^(3/2)
// | -------------------------------- |
// |   (1-g^2) / (1+g^2-2*g*sign(g))  |
//
// which becomes:
// [ (1+g^2-2*g*sign(g)) / (1+g^2-2*g*cos(theta)) ]^(3/2)
//
float hgphaseN(float g; vector wi, wo) {
   float out = 1; // equal probability when g==0
   if(g!=0) {
      float gg = clamp(g,-1.+1e-6,1.-1e-6);
      float g2 = gg*gg;
      float a  = 1.0 + g2;
      float b  = 2.0*gg;
      out = pow( (a-(b*sign(g))) / (a-(b*dot(-wi,wo))), 1.5);
   }
   return out;
}
vector hgphaseNv(vector g; vector wi, wo) {
   return set( hgphaseN(g.x,wi,wo), hgphaseN(g.y,wi,wo), hgphaseN(g.z,wi,wo));
}

// This is the relative intensity of forward scattering for a given 'g'.
// Assumes total scattering is unity and so when g==0 the forward portion 
// is 0.5. Therefore, for 'g' in [-1,1] it returns pcnt_fwd in [0,1] with
// 0.5 at g==0. It is the integral of the forward hemisphere of hgphase(g).
// TODO: This ends up being a very simple monotonically increasing s-curve
// and should be replaceable by a cheaper approximation, or a lookup table.
float hgforward(float g) {
   float gg  = clamp(g,-1.+1e-6,1.-1e-6);
   float out = 0.5;                      // trivial g==0
   if(gg<0 && abs(gg+1.0)<1e-4) {        // trivial g~=-1
      out = 0;
   } else if(gg>0 && abs(gg+1.0)<1e-4) { // trivial g~=+1
      out = 2;
   } else if(gg!=0) {
      float a = sqrt(1.0+(gg*gg)); // = 1/cos(atan(g))
      out = ( (1.+gg)*(-1.+gg+(a*sign(1.-gg))) ) / (2.*gg*a);
   }
   return out;
}
vector hgforwardv(vector g) {
   return set( hgforward(g.x), hgforward(g.y), hgforward(g.z));
}



// -------------------------------------------------------------------------------
// Noise (fBm only)
// -------------------------------------------------------------------------------
#define NR3L 0.092
#define NR3H 0.828
#define NR4L 0.115
#define NR4H 0.933
#define ntnorm3(rt,f) fit(f,(rt)NR3L,(rt)NR3H,(rt)0,(rt)1)  //f3.hst
#define ntnorm4(rt,f) fit(f,(rt)NR4L,(rt)NR4H,(rt)0,(rt)1)  //f4.hst
#define BASENOISE3(rt,p)             ntnorm3(rt,rt(noise(p)))
#define BASENOISE4(rt,pT)            ntnorm4(rt,rt(noise(pT)))

float noise3   (vector p)           { return BASENOISE3(float,p); }
float snoise3  (vector p)           { return 2.0*noise3(p)-1.0; }
float noise4   (vector p; float T)  { return BASENOISE4(float,set(p.x,p.y,p.z,T)); }
float snoise4  (vector p; float T)  { return 2.0*noise4(p,T)-1.0; }

#define FADE3      (1.0 - smooth(NR3L, NR3H, fw))
#define FADE4      (1.0 - smooth(NR4L, NR4H, fw))
float F_snoise3(vector p; float fw)          
   { return snoise3(p)*FADE3; }
float F_snoise4(vector p; float T, fw)        
   { return snoise4(p,T)*FADE4; }
#undef FADE3
#undef FADE4

// fBm noise - 3D, float (from vex/noise.h)
// Continuous octaves and normalized signed ouput [-1,1]
float noise_fBm3(vector p; float fw,maxoctaves,lacunarity,gain) { 
   vector pp=p; 
   float sum = 0; 
   float amp = 1, k=0, i=1; 
   while(i<=maxoctaves) { 
      sum+=amp*float(F_snoise3(pp,fw)); 
      pp*=lacunarity; 
      k+=amp*amp; amp*=gain; 
      i+=1.0; 
   } 
   if(fw<1.0 && i>maxoctaves) { 
      i=modulo(maxoctaves,1.0); 
      if(i>1.19209290e-07) { 
         sum += i*amp*float(F_snoise3(pp,fw)); 
         k+=i*(amp*amp); 
      } 
   } 
   float div=sqrt(k); 
   sum = div==0.0 ? sum : (sum/div); 
   sum = clamp(sum,-1.0,1.0); 
   return sum; 
}

// fBm noise - 4D, float (from vex/noise.h)
// Continuous octaves and normalized signed ouput [-1,1]
float noise_fBm4(vector p; float T; float fw,maxoctaves,lacunarity,gain) { 
   vector pp=p; 
   float TT=T; 
   float sum = 0; 
   float amp = 1, k=0, i=1; 
   while(i<=maxoctaves && fw<1.0) { 
      sum+=amp*float(F_snoise4(pp,TT,fw)); 
      pp*=lacunarity; TT*=lacunarity; fw*=lacunarity; 
      k+=amp*amp; amp*=gain; 
      i+=1.0; 
   } 
   if(fw<1.0 && i>maxoctaves) { 
      i=modulo(maxoctaves,1.0); 
      if(i>1.19209290e-07) { 
         sum += i*amp*float(F_snoise4(pp,TT,fw)); 
         k+=i*(amp*amp); 
      } 
   } 
   float div=sqrt(k); 
   sum = div==0 ? sum : (sum/div); 
   sum = clamp(sum,-1.0,1.0); 
   return sum; 
}



// -------------------------------------------------------------------------------
// Field Manipulation
// -------------------------------------------------------------------------------

// rampf - helper: solve a float ramp... saves some typing
float rampf(float t0; string r_basis[]; float r_keys[]; float r_vals[]) {
   return spline(r_basis,spline("linearsolve",t0,r_keys),r_vals);
}

// rampc - helper: solve a color/vector ramp... saves some typing
vector rampc(float t0; string r_basis[]; float r_keys[]; vector r_vals[]) {
   return spline(r_basis,spline("linearsolve",t0,r_keys),r_vals);
}

// log to the given base
float logb(float base, x) {
   return log(x) / log(base);
}

// Soft Clip - reduces a field's high-intensity range by
// smoothly compressing it into a log scale (beyond a given threshold).
// A smoother version of a "ceiling clamp".
float softclip (
      float f; // field value
      float s; // start val for compression
      float c; // compression
   )
{
   float out = f;
   if(f>s && c>0) {
      float ki = 1.0 / c;
      float w  = 1.0 / (c*log(10.0));
      float v  = log10(pow(w,ki));
      out = log10(pow((f-s)+w,ki)) - v + s;
   }
   return out;
}

vector softclipv(vector c; float s, k) {
   return set(softclip(c.r,s,k),softclip(c.g,s,k),softclip(c.b,s,k));
}

// Contour - adds contrast to a field's low-intensity range by
// smoothly attenuating values below a given threshold.
// A smoother version of a "floor clamp".
float contour (
      float f; // field value
      float e; // field value interpreted as the "contour" edge
      float s; // sharpening amount [0,+inf] (practical range [0,10])
   )
{
   // Equivalent to (3*x^2 - 2*x^3)^s, with x = clamp(f/e,0,1), { e > 0 }
   return f * pow(smooth(0,e,f),s);
}


// -------------------------------------------------------------------------------
// Filter Size Estimation
// -------------------------------------------------------------------------------

// Filter size estimation based on depth.
// Until Andrew brings back shading differentials back to the volume engine, 
// the best we can do is base the "feature size" of fBm noise on some distance
// function.
// It uses the image plane geometry, sampling rate, and output resolution
// (as reported by renderstate()), and the fact that feature size increases
// linearly with distance, modulated by a facing ratio (dot(N,-I)), to 
// arrive at a final approximation (which can be scaled by the user).
float featuresize(
      float depth;   // depth from camera plane
      vector freq;   // noise frequency (in current space)
   ) 
{
   // camera and image defaults
   float  camzoom   = 1.21319; // => aperture/focal (at default);
   vector imgres    = {640,480,3};
   vector imgsamps  = {3,3,0};
   vector imgrsamps = {3,3,0};
   
   renderstate("image:resolution" ,imgres    );
   renderstate("image:samples"    ,imgsamps  );
   renderstate("image:raysamples" ,imgrsamps );
   renderstate("camera:zoom"      ,camzoom   );
   return max(1e-9, (depth*camzoom*length(freq)) / max(imgres*imgsamps) );
}


// -------------------------------------------------------------------------------
// Point Cloud Support
// -------------------------------------------------------------------------------

// Gather scattered emission/radiance onto the given poincloud point
// This is meant to be called by the main scattering interface pc_ssvol().
// For this reason, it ommits some checks, so be careful calling it.
vector pc_ssvolI (
      string fname;     // the pointcloud file for emission (fire)
      string aname;     // the name of the *vector* attribute (color) to scatter
      vector Psh;       // shading position (a pointcloud point position)
      vector wo;        // viewing (or outgoing) direction (unit length)
      float  shden;     // density at current shading point (density at global P)
      float  pcden;     // density at caller's position (smoke pc density)
      float  maxrad;    // max search radius
      int    maxpts;    // max points to gather
      int    maxfail;   // terminate loop when this many non-contributors is reached
      float  attdens;   // density attenuation coefficient => exp(-katten*x)
      float  attdist;   // distance attenuation coefficient => 1/(d*attdist)^2
      string shtype;    // shadow type (0=none, 1=hard, 2=filtered)
      float  thresh;    // minimum intensity contribution
      float  phase;     // eccentricity for the phase function [-1,1]
   )
{
   vector out = 0;  // returned value

   int handle = pcopen(fname,"P",Psh,maxrad,maxpts);
   if(handle>=0) {
      vector Ppc   = 0; // pc position
      vector Apc   = 0; // pc attribute (which gets scattered)
      vector scatt = 0; // pc scattering coeff
      float  d     = 0; // distance from Psh to Ppc
      vector csum  = 0; // sum of all "aname" contributions
      vector wsum  = 0; // sum of all contribution weights (vector for filtered shadows)
      float  realrad = 0; // keep track of furthest sample
      int    duds  = 0; // counts non-contributing samples (<thresh intensity)
      int    live  = 0; // counts actual contributors
      int    total = 0; // counts total points visited
      while(pciterate(handle) && duds<maxfail) { // && live<maxpts) {
         if( pcimport(handle,"P",Ppc) && 
             pcimport(handle,aname,Apc) &&
             pcimport(handle,"point.distance",d) )
         {
            vector pdelta = Ppc-Psh;

            // don't include the caller's own point as contributor
            // and don't include non-emitters (Apc<1e-6)
            if(abs(max(pdelta))>1e-4 && max(Apc)>1e-6) {
               vector wi = normalize(Ppc-Psh);

               // init to source color (pre-scaled by the volume, when saved!!)
               vector c  = Apc;

               // atten due to phase
               vector w = hgphase(phase,wi,wo);
               w = lerpv((vector)0.2,w,smoothv(VZERO,(vector)0.3,w));

               // atten due to density (approximated, or via shadow calls)
               if(shtype=="filtered") 
                  w *= filtershadow(Psh,pdelta,0)/max(1e-6,attdens);
               else 
                  w *= exp(-d*pcden*attdens); // approx atten

               // atten due to distance (pcpoints are point sources)
               float datten = d*attdist;
               w /= min(1,datten*datten); // clamped
               //w /= 1+datten*datten; // non-asymptotic

               // apply attenuation
               c *= w;

               // update accumulators
               if(max(c)<thresh) duds+= 1; else duds=0;
               if(d>realrad) realrad=d;
               csum += c;
               wsum += w;
               live += 1;
            }
            total += 1;
         }
      }

      // As a normalization factor, I'm using the integral of the two main
      // attenuations (eponential density and the clamped inv_square distance) 
      // over the volume of the sphere with radius maxrad. 
      // With a=attdens, b=attdist, and r=min(maxrad,realrad), this becomes:
      //
      //  /2PI /PI /r
      //  |    |   |  exp(-r*a)*r^2 / max(1,(b*r)^2) sin(th) dr dth dph
      //  /0   /0  /0
      //
      // Which solves to:
      //
      // 4*exp(-a*r)*PI*(-2 + 2*exp(a*r) - 2*a*r - a^2 * r^2) / a^3

      //
      //printf("Total: %g, Live: %g, Duds: %g\n",total,live,duds);
      //printf("Csum: %g, %g\n",csum,csum / ( ((4./3.)*C_PI*maxrad*maxrad*maxrad) ));
      //out = csum / maxfv(1e-6,wsum) );
      //float norm = 2.*(2.-2.*exp(-maxrad*attdens))*C_PI / (attdens*attdist*attdist);

      float a    = attdens;
      float b    = attdist;
      float r    = maxrad; //min(realrad,maxrad);

      //float norm = 2. + attdens*maxrad;
      //norm = 2.*(2. + attdens*maxrad*norm);
      //norm = 2.*exp(-attdens*maxrad)*C_PI*(4.*exp(attdens*maxrad)-norm) /
      //       attdens*attdens*attdens;

      //float norm = ( 4.0*exp(-a*r)*C_PI* 
      //             (-2.0 + (2.0*exp(max(80,a*r))) - (2.0*a*r) - (a*a*r*r)) ) / (a*a*a);

      //float norm = 2.*(20.-(20.*exp(-a*r)))*C_PI / a;
      float norm = 4000*(1.-exp(-a*r))*C_PI / a;

      //float norm;
      //if(b>0 && (1./b)-r<0) 
      //   norm = ( 4.*exp(-(a/b)-(a*r)) * 
      //          (-(a*a)*exp(a/b) - (2.*a*b*exp(a*r)) 
      //           - (2.*b*b*exp(a*r)) + (2.*b*b*exp((a/b)+(a*r))) ) * C_PI ) /
      //          (a*a*a*b*b);
      //else
      //   norm = ( 4.*exp(-a*r)*C_PI* (-2. + (2.*exp(a*r)) - (2.*a*r) - (a*a*r*r)) ) /
      //          (a*a*a);

      //float norm;
      //float ib=1.0/max(1e-6,b);
      //if((b==0 && r>0) || (b>=0 && r>0 && ib-r>=0))
      //   norm = ( 4.*exp(-a*r)*(exp(a*r)-1.0)*C_PI ) / ( a*b*b );
      //else
      //   norm = (4.0/(a*a*a*b*b)) * exp(-(a/b)-(a*(ib+r))) * C_PI *
      //          ( - (2.0*b*b*exp(2*a/b)) + (a*a*exp(a*(ib+r))) + (a*a*exp((a/b)+(a*r)))
      //            + (2.*a*b*exp((a/b)+(a*r))) + (2.*b*b*exp((1/b)+(a*r)))
      //            + (a*a*exp((a/b)+(a*(ib+r)))) - (2.*a*b*b*exp(2.*a/b)*r)
      //            - (a*a*b*b*exp(2.*a/b)*r*r)
      //          );

      //printf("norm: %g\n",norm);
      out = csum/(norm);
      pcclose(handle);
   }
   return out;
}
      
// Calculates scattered emission/radiance in a volume (using point clouds)
// ... and only to a rough single scattering approximation.
// Space-related parameters (Psh,Nsh, etc) are assumed to be in the same
// space as that used when creating the point cloud. All vectors unit length.
vector pc_ssvol (
      string pcsmoke;   // the pointcloud file for smoke
      string pcfire;    // the pointcloud file for fire
      string aname;     // the name of the *vector* attribute (color) to scatter
      vector Psh;       // shading position
      vector wo;        // viewing (or outgoing) direction (unit length)
      float  srcden;    // shade point's density
      float  maxrad;    // max search radius
      int    isamps;    // max integration samples
      int    fsamps;    // max filter samples
      int    maxfail;   // terminate loop when this many non-contributors is reached
      float  attdens;   // density attenuation coefficient => exp(-katten*x)
      float  attdist;   // distance attenuation coefficient => 1/(d*attdist)^2
      string shtype;    // shadow type (0=none, 1=filtered)
      float  thresh;    // minimum intensity contribution
      float  phase;     // eccentricity for the phase function [-1,1]
   )
{
   vector out = 0;  // returned value

   if(pcsmoke!="" && maxrad>0 && fsamps>0 && isamps>0) {
      int handle = pcopen(pcsmoke,"P",Psh,1e9,fsamps);
      if(handle>=0 && pcfarthest(handle)<1e9) {
         vector Ppc    = 0;                     // pc position
         float  pcden  = 0;                     // pc density
         while(pcunshaded(handle,aname)) {
            vector ss = 0;
            if(pcimport(handle,"P",Ppc) && pcimport(handle,"density",pcden) ) {
               ss = pc_ssvolI(pcfire,aname,Ppc,wo, srcden, pcden, maxrad,
                              isamps,maxfail,attdens,attdist,shtype,thresh,phase);
            }
            if(!pcexport(handle,aname,ss,"storage","real32")) break;
         }
         out = pcfilter(handle,aname);
         pcclose(handle);
      }
   }
   return out;

}

// Write empty point data to a "smoke" point cloud file
int pc_writesmoke (
      string fname;     // the pointcloud file name
      float  den;       // current density
   )
{
   int status = 0;
   status = pcwrite( fname 
                     ,"interpolate",   1
                     ,"P",             P
                     ,"density",       den
                   );
   return status;
}

// Write emission data to a "fire" point cloud file
int pc_writefire (
      string fname;     // the pointcloud file name
      string aname;     // attribute name
      vector col;       // emission color
   )
{
   int status = 0;
   status = pcwrite( fname 
                     ,"interpolate",   1
                     ,"P",             P
                     ,aname,           col
                     );
   return status;
}






// -------------------------------------------------------------------------------
// Field Management. How the various fields are mapped internally
// -------------------------------------------------------------------------------
//
// Maintenance Notes:
//
// All values that can be referenced in a "field" or "modifier" parameter
// in the shader UI, are treated equally as "fields" inside the shader code.
// The values (all scalar) of these fields then, can come from three 
// possible sources:
// 1. A bound field, such as "density"
// 2. A shader-generated field, such as "speed" (which depends on bound::vel)
// 3. A modifier ("field shaper" or "noise generator"), both of which are
//    really just "field generators".
//
// Because there are no global variables in VEX, some static arrays
// are turned into functions with const return values. The ones that
// pertain to maintaining field naming and their associated index mappings are:
//
// This returns the string names of all supported fields.
// string[] fieldnames()
//
// This returns the index of the given field name.
// int fieldid(string fieldname)
// 
// for all fields:
// 1. evaluate bound fields (simple assignment):
//    int fid = fieldid("density"); fieldvals[fid]=density;
//    fid = fieldid("temperature"); fieldvals[fid] = temperature;
//    etc.
//
// 2. evaluate shader fields (simple assignment):
//    fid = fieldid("speed"); fieldvals[fid]=speed;
//    etc.
//
// 3. evaluate field mods iff in use
//    if(fieldinuse("fmod1",sites)) evalmodf(...,FMOD_PARMS(1));
//    if(fieldinuse("fmod2",sites)) evalmodf(...,FMOD_PARMS(2));
//
// 4. evaluate noise mods iff in use
//    if(fieldinuse("nmod1",sites)) evalmodn(...,NMOD_PARMS(1));
//    if(fieldinuse("nmod2",sites)) evalmodn(...,NMOD_PARMS(2));
//
// At this point, all values in fieldvals[] will have been set (either by
// direct assignment, or by cooking some modifier) and can be used by the
// shading code. When a modifier needs to be applied, the site's reference
// (a filed name) gets dereferenced with fieldid(name).
// float var = something * fieldvals[fieldid(modsite_val)][0];
// -------------------------------------------------------------------------------


// This returns the names of all the supported fields.
// MAINTENANCE: This static array needs to be updated whenever a new field
// is added to the list of supported fields.
string[] fieldnames() {
   return array(   "density"        // bound fields
                 , "temperature"
                 , "heat"
                 , "burn"
                 , "age"

                 , "spare1"         // user fields
                 , "spare2"
                 , "spare3"
                 , "spare4"
                 , "spare5"
                 , "spare6"

                 , "speed"          // shader fields
                 , "time"

                 , "fmod1"          // field shapers
                 , "fmod2"
                 , "fmod3"
                 , "fmod4"
                 , "fmod5"
                 , "fmod6"

                 , "nmod1"          // noise generators
                 , "nmod2"
                 , "nmod3"
                 , "nmod4"
               );
}

int fieldid(string name) {
   int    id   = -1;
   string fn[] = fieldnames();
   for(id=0;id<arraylength(fn);id++) if(fn[id]==name) break;
   return id;
}

int fieldinuse(string name; string sitevals[]) {
   int inuse = 0;
   int i;
   for(i=0;i<arraylength(sitevals);i++) {
      if(sitevals[i]==name) { inuse=1; break; }
   }
   return inuse;
}


// -------------------------------------------------------------------------------
// Mod Evaluation
// -------------------------------------------------------------------------------

// Dereferencing macros:

// These convenience macros take an array of field values (which is always
// the same main array that gets created in the shader and then gets passed
// around to functions), and a field name to resolve it to a value reference.

// field reference|value (either rh-value or lh-assignable)
#define FIELDREF(arrname,fname) arrname[fieldid(fname)]

// apply a scalar mod
#define APPLYMOD(op,val,arrname,modname)    \
   ((modname!="none") ? mod##op ( val, FIELDREF(arrname,modname)) : val)

// apply three scalar mods (hsv) to a color
#define APPLYRGBMODS(op,val,arrname,nameh,names,namev)    \
   modrgb##op (val, ((nameh!="none") ? FIELDREF(arrname,nameh) : VONE), \
                    ((names!="none") ? FIELDREF(arrname,names) : VONE), \
                    ((namev!="none") ? FIELDREF(arrname,namev) : VONE) )


// Evaluators:

float evalrampf(float x; RAMP_PARMS(r_,rng,0)) {
   return rampf(x,r_rngw0b,r_rngw0k,r_rngw0v);
}

vector evalrampc(float x; RAMPC_PARMS(r_,rng,0)) {
   return rampc(x,r_rngw0b,r_rngw0k,r_rngw0v);
}

// Fields
// The second and third components of the ouput vector are not used for
// modified fields -- they're set to 1.
vector evalmodf(vector fvals[]; FSHAPE_PARMS(mf_,0)) {
   float val = 1;

   if(mf_enable0) {
      // base field value to modify
      val = fvals[fieldid(mf_field0)][0]; 

      // contour
      if(mf_tsharp0 && mf_sharpk0>0 && val<mf_sharpe0)
         val = contour(val,mf_sharpe0,mf_sharpk0);

      // softclip
      if(mf_tsoft0 && mf_softk0>0 && val>mf_softe0) 
         val = softclip(val,mf_softe0,mf_softk0);

      // range mapping
      if(mf_trng0 ) {
         val = fit(val,mf_rngsl0,mf_rngsh0,mf_rngtl0,mf_rngth0);
         float x = fit(val,mf_rngtl0,mf_rngth0,0,1);
         //if(x>0 && x<1) {
            float rval = evalrampf(x,RAMP_ARGS(mf_,rng,0));
            val = lerp(mf_rngtl0,mf_rngth0,rval);
         //}
      }
   }
   return set(val,1,1);
}


// Noises
// The output vector is: { noise, amplitude, field_weight }
// Not an integrated value because these terms may be combined differently
// for different applications (like modifying a density versus a parameter)
vector evalmodn(
      float    depth;      // for feature size calc
      float    time;       // for 4d noise
      int      dualrest;   // whether to use dual rest fields
      vector   pr1,pr2;    // dual rest positions to eval noise at
      float    drframe;    // dual rest: curr frame
      float    drstart;    // dual rest: initial rest frame
      float    drrate;     // dual rest: reset rate (in frames)
      vector   fvals[];   // field values
      NOISE_PARMS(mn_,0)
   ) 
{
   vector out = {1,1,1}; // {noise,amplitude,fieldweight}

   if(mn_enable0) {
      // base field value to modify
      float weight = 1;
      if(mn_field0!="none") {
         weight = fvals[fieldid(mn_field0)][0];
         weight = evalrampf(fit(weight,mn_rngsl0,mn_rngsh0,0,1), RAMP_ARGS(mn_,rng,0));
      }

      // calc noise
      if(weight!=0) {
         float  chaos = 1;

         float  g = APPLYMOD(scale,mn_gain0,fvals,mn_gainm0);
         g = max(1e-4,g);
         float  oct = APPLYMOD(scale,mn_oct0,fvals,mn_octm0);
         oct = max(1,oct);
         float  lac = APPLYMOD(scale,mn_lac0,fvals,mn_lacm0);
         lac = max(1,lac);
         float  expon = APPLYMOD(scale,mn_expon0,fvals,mn_exponm0);
         expon = max(1e-6,expon);

         vector wfreq = ow_vspace((vector)mn_freq0);
         float  fw    = mn_fw0 * featuresize(depth,wfreq);
         vector p1    = pr1*(vector)mn_freq0 - (vector)mn_off0;
         float  mnT;
         if(mn_is4d0) {
            mnT   = time*mn_freq0[3] - mn_off0[3];
            chaos = noise_fBm4(p1,mnT,fw,oct,lac,g)*.5+.5;
         } else chaos = noise_fBm3(p1,fw,oct,lac,g)*.5+.5;

         // If we're calculating noise based on cyclic dual rest fields
         // we sample the noise again at the second rest position and
         // blend the two results.
         if(dualrest) {
            float  chaos2 = chaos;
            // force decorrelation of chaos2 by offsetting it a const large amount
            vector p2 = (pr2*(vector)mn_freq0 - (vector)mn_off0) + 7654.321;
            if(mn_is4d0) chaos2 = noise_fBm4(p2,mnT,fw,oct,lac,g)*.5+.5;
               else chaos2 = noise_fBm3(p2,fw,oct,lac,g)*.5+.5;

            // lerp weight
            float drw = modulo(drframe-drstart,drrate);
            drw = smooth(0,drrate*0.5,drw) - smooth(drrate*0.5,drrate,drw);

            // correct the intensity drop due to blend by scaling the blended
            // noises by the inverse of the variance, where
            // variance = a^2 + (1-a)^2 { a = "alpha" or "blend weight" }
            // This is a "half circle" with values (1,.5,1) at a = (0,.5,1),
            // so as an inverse weight it becomes (*1,*2,*1) for a=(0,.5,1)

            // TODO: Not convinced with the variance correction yet... have to
            // study it further, right now my tests seem to indicate it's not
            // needed (actually, I'm seeing a boost at the seams), but the 
            // wavelet noise paper gives it as a necessary correction for 
            // blending the edges of their noise tiles.
            // --- Temporarily on hold ----
            //float idrw = 1.0-drw;
            //float var  = (drw*drw) + (idrw*idrw);
            //chaos = lerp(chaos2,chaos,drw) / var;

            chaos = lerp(chaos2,chaos,drw);
         }

         // apply exponent (while we're [0,1] )
         if(expon!=1) chaos = pow(chaos,expon);

         // fit to output range
         if(mn_rngol0!=0 || mn_rngoh0!=1) chaos = fit(chaos,0,1,mn_rngol0,mn_rngoh0);

         // fetch and apply amplitude
         float amp = mn_amp0;
         if(mn_ampm0!="none") amp*=(fvals[fieldid(mn_ampm0)])[0];
         chaos *= amp;

         //out = set(chaos,amp,weight);
         out = lerp(mn_rngol0,chaos,weight);
      }
   }
   
   return out;
}



// -------------------------------------------------------------------------------
// Parameter Evaluation (for parameters which accept mods)
// -------------------------------------------------------------------------------

// Apply modifier as a mixture (accentuates contrast -- warning: positive
// values can become negative with this method)
float modmix(float val; vector modval) {
   return lerp(val,lerp(val,val*modval[0],modval[1]),modval[2]);
   //return lerp(val,val*modval[0]*modval[1],modval[2]);
   //return lerp(val,modval[0]*modval[1],modval[2]);
}
// Apply modifier as a straight coefficient
float modscale(float val; vector modval) {
   return val*modval[0]*modval[1]*modval[2];
}

// Multiple modifiers for colors
vector modrgbmix(vector rgb; vector mhue, msat, mval) {
   vector out = rgbtohsv(rgb);
   if(mhue[0]!=0) out[0] = lerp(out[0],lerp(out[0],out[0]*mhue[0],mhue[1]),mhue[2]);
   if(msat[0]!=1) out[1] = lerp(out[1],lerp(out[1],out[1]*msat[0],msat[1]),msat[2]);
   if(mval[0]!=1) out[2] = lerp(out[2],lerp(out[2],out[2]*mval[0],mval[1]),mval[2]);
   return hsvtorgb(out);
}
vector modrgbscale(vector rgb; vector mhue, msat, mval) {
   vector out = rgbtohsv(rgb);
   if(mhue[0]!=0) out[0] += mhue[0];
   if(msat[0]!=1) out[1] *= msat[0]; 
   if(mval[0]!=1) out[2] *= mval[0]; 
   return hsvtorgb(out);
}



// -------------------------------------------------------------------------------
// Shader
// -------------------------------------------------------------------------------

surface pyro (
      string  mode            = "shade"; // shading mode
      float   time            = 0;       // Current Time
      float   frame           = 0;       // Current Frame

      // Dual Rest Position controls
      int     dr_enable       = 1;       // enable dual rest
      float   dr_start        = 1;       // initial rest frame
      float   dr_rate         = 20;      // reset rate

      // Smoke
      // -------------------------
      int     s_enable    = 1;              // enable smoke visibility

      string  s_field     = "density";      // field
      string  s_fieldm    = "none";         // field modifier
      float   s_fieldk    = 500;            // field scale
      string  s_fieldkm   = "none";         // field scale modifier

      int     s_usecd     = 1;              // whether to tint with bound Cd
      vector  s_hue       = 1;
      string  s_huemh     = "none";         // smoke hue: hue modifier
      string  s_huems     = "none";         // smoke hue: saturation modifier

      float   s_alb       = 1;
      string  s_albm      = "none";         // smoke albedo modifier

      vector  s_phase     = 0;              // scattering phase
      string  s_phasemr   = "none";         // scattering phase: mod R
      string  s_phasemg   = "none";         // scattering phase: mod G
      string  s_phasemb   = "none";         // scattering phase: mod B

      vector  s_shadh     = 1;
      string  s_shadhmh   = "none";         // shadow hue: hue modifier
      string  s_shadhms   = "none";         // shadow hue: saturation modifier

      float   s_shadk     = 1;
      string  s_shadkm    = "none";         // shadow intensity modifier

      // Color Correction
      int     s_ccenable  = 0;
      vector  s_cchsv     = {0,1,1};
      vector  s_cccont    = 1;
      vector  s_ccgamma   = 1;
      vector  s_cctint    = 1;       


      // Burn
      // -------------------------
      int     b_enable     = 0;              // enable burn visibility

      string  b_tfield     = "temperature";  // temperature field
      string  b_tfieldm    = "none";         // temperature field modifier

      float   b_amp        = 1;              // emission amplitude
      string  b_ampm       = "none";         // emission amplitude modifier

      string  b_dfield     = "none";         // density field
      string  b_dfieldm    = "none";         // density field modifier

      float   b_kdens      = 0;              // emission density scale
      string  b_kdensm     = "none";         // emission density scale modifier

      float   b_blend      = 1;              // emission density blend
      string  b_blendm     = "none";         // emission density blend modifier

      string  b_model      = "physical";     // color model
      int     b_usecd      = 1;              // whether to tint with bound Cd

      float   bph_temp     = 4000;           // physical: core temperature
      string  bph_tempm    = "none";         // physical: core temperature modifier
      float   bph_kcool    = 0;              // physical: red (cool) boost
      string  bph_kcoolm   = "none";         // physical: red (cool) boost modifier
      float   bph_bshift   = 0;              // physical: blue shift
      string  bph_bshiftm  = "none";         // physical: blue shift modifier
      int     bph_tksoft   = 0;              // physical: enable sofclip intensity
      float   bph_ksofte   = 0.5;            // physical: softclip start
      float   bph_ksoftk   = 5;              // physical: softclip compression    

      RAMPC_PARMSDFLT(ba,_,c);               // artistic: hue ramp
      RAMP_PARMSDFLT(ba,_,k);                // artistic: intensity ramp

      // Color Correction
      int     b_ccenable     = 0;
      vector  b_cchsv        = {0,1,1};
      vector  b_cccont       = 1;
      vector  b_ccgamma      = 1;
      vector  b_cctint       = 1;       



      // Self Scattering (pc-based)
      // -------------------------
      string  ss_pcsmoke      = "";      // scattering: smoke pc filename
      string  ss_pcfire       = "";      // scattering: fire pc filename
      int     ss_enable       = 0;       // whether to enable scattering
      float   ss_amp          = 0.2;     // scattered amplitude (dimmer)
      float   ss_attdens      = 1;       // density attenuation scale
      float   ss_attdist      = 1;       // distance attenuation scale
      float   ss_phase        = 0.5;     // eccentricity of phase function [-1,1]
      float   ss_rad          = 0.5;     // max search radius
      int     ss_isamps       = 1000;    // max integration samples
      int     ss_fsamps       = 8;       // max filter samples
      string  ss_shtype       = "none";  // shadow type (none, filtered)
      // Color Correction
      int     ss_ccenable     = 0;
      vector  ss_cchsv        = {0,1,1};
      vector  ss_cccont       = 1;
      vector  ss_ccgamma      = 1;
      vector  ss_cctint       = 1;       // tinting of scattered color

      // Field Modifiers
      // -------------------------
      FSHAPE_PARMSDFLT(mf_,1);
      FSHAPE_PARMSDFLT(mf_,2);
      FSHAPE_PARMSDFLT(mf_,3);
      FSHAPE_PARMSDFLT(mf_,4);
      FSHAPE_PARMSDFLT(mf_,5);
      FSHAPE_PARMSDFLT(mf_,6);

      // Noise Modifiers
      // -------------------------
      NOISE_PARMSDFLT(mn_,1);
      NOISE_PARMSDFLT(mn_,2);
      NOISE_PARMSDFLT(mn_,3);
      NOISE_PARMSDFLT(mn_,4);

      // Bound Geometry Attributes
      // -------------------------
      vector Cd               = 1;        // point color

      // Fields
      // -------------------------

      // Standard volume fields
      float  density          = 0;
      float  temperature      = 0;
      float  heat             = 0;
      float  burn             = 0;
      float  age              = 0;
      vector vel              = 0;
      vector rest             = 0;
      vector rest2            = 0;        // rest2 used for cycling rest positions

      // Extra, user-defined scalar fields
      float  spare1           = 0;
      float  spare2           = 0;
      float  spare3           = 0;
      float  spare4           = 0;
      float  spare5           = 0;
      float  spare6           = 0;

      // Output Layers
      export vector  Csmoke   = 0;        // Smoke: Color
      export float   Asmoke   = 0;        // Smoke: Coverage (alpha)
      export vector  Cfire    = 0;        // Burn: Color
      export float   Afire    = 0;        // Burn: Coverage (alpha)
      export float   Mfire    = 0;        // Burn: Mask
      export vector  Opyro    = 0;        // Combined final opacity
      export vector  Cscatt   = 0;        // Scattered Illumination
      export vector  Escatt   = 0;        // Scattered Emission

      export vector  Ce       = 0;


      // Parameters which exist in the UI but are not used by the shader
      // These are here to stop Mantra from complaining
      // ---------------------------------------------------------------
      float  pcgen_steps      = 0.5;
      float  pcgen_stepf      = 0.5;
      string pcgen_cam        = "/obj/cam1";
      int    pcgen_tfrng      = 0;
      int    pcgen_frng1      = 1;
      int    pcgen_frng2      = 300;
      string pcgen_mode       = "samestep";
      int    pcgen_execute    = 0;


   )
{  
   // Velocity and Speed
   vector velocity = 0;
   float  speed    = 0;
   if(isbound("vel")) {
      velocity = vtransform("space:object","space:current",vel);
      speed    = length(velocity);
   }

   // Volume -- TODO: replace this when Andrew fixes dPds/dPdt
   // Should eventually become: vol = length(dPds)*length(dPdt)*dPdz;
   float vol = dPdz;

   // Render engine
   string engine; renderstate("renderer:renderengine", engine);
   int ismp  = (engine=="micropoly") || (engine=="pbrmicropoly");
   int ispbr = (engine=="pbrraytrace") || (engine=="pbrmicropoly");

   // Shading vars
   vector nN = normalize(N);
   vector nV = normalize(-I);

   // determine pcwrite mode
   int pcwfire  = (mode=="pcwrite_fire");
   int pcwsmoke = (mode=="pcwrite_smoke");
   int pcwall   = (mode=="pcwrite_all");
   if(pcwall) pcwfire = pcwsmoke = 1;
   int pcwany   = (pcwfire || pcwsmoke);

   // Determine rest position. If only one of rest or rest2 is bound,
   // then Prest is assigned its value. If both are available, then the
   // shader will cycle between them. If none are available, we fall back
   // to object-space P.
   vector Prest = rest, Prest2 = rest2;
   int dualrest  = 0;
   if(isbound("rest2") && dr_enable) dualrest = 1; 
      else if(!isbound("rest")) Prest = ptransform("space:object",P); 


   // Evaluate all Fields and Generators/Modifiers
   //----------------------------------------------------------------------


   // Build an array to hold the value of all modulator sites.
   // MAINTENANCE: This needs to be updated whenever a new modulator is 
   // attached to a parameter.
   string sitevals[] = array (  s_field      // smoke: field
                               ,s_fieldm     // smoke: field modifier
                               ,s_fieldkm    // smoke: field density modifier
                               ,s_huemh      // smoke: hue: hue modifier
                               ,s_huems      // smoke: hue: saturation modifier
                               ,s_albm       // smoke: albedo modifier
                               ,s_phasemr    // smoke: scattering phase: mod R
                               ,s_phasemg    // smoke: scattering phase: mod G
                               ,s_phasemb    // smoke: scattering phase: mod B
                               ,s_shadhmh    // smoke: shadow hue: hue modifier
                               ,s_shadhms    // smoke: shadow hue: saturation modifier
                               ,s_shadkm     // smoke: shadow intensity modifier
                               ,b_tfield     // fire: temperature field
                               ,b_tfieldm    // fire: temperature field modifier
                               ,b_dfield     // fire: density field
                               ,b_dfieldm    // fire: density field modifier
                               ,b_ampm       // fire: amplitude modifier
                               ,b_kdensm     // fire: density amplitude modifier
                               ,b_blendm     // fire: density blend rate  modifier
                               ,bph_tempm    // fire: physical: temp modifier
                               ,bph_kcoolm   // fire: physical: red boost modifier
                               ,bph_bshiftm  // fire: physical: blue boost modifier
                               ,NOISE_MODS(mn_,1) // Sites within noise generators
                               ,NOISE_MODS(mn_,2)
                               ,NOISE_MODS(mn_,3)
                               ,NOISE_MODS(mn_,4)
                             );


   // Build the array that will hold all evaluated field values. (fieldvals[])
   // These are vectors even though the fields themselves are scalars.
   // The reason for this is that it's necessary to keep some of the
   // generator results as separate components because they can be
   // combined differently depending on the type of modulation (true
   // only for noise generators at the moment).

   vector fieldvals[] = vector(array());
   resize(fieldvals,arraylength(fieldnames()));

   // Evaluate the bound fields (direct assignment, no evaluation needed)
   // MAINTENANCE: Update this whenever a new bound field is added
   FIELDREF(fieldvals,"density")     = (vector)density;
   FIELDREF(fieldvals,"temperature") = (vector)temperature;
   FIELDREF(fieldvals,"heat")        = (vector)heat;
   FIELDREF(fieldvals,"burn")        = (vector)burn;
   FIELDREF(fieldvals,"age")         = (vector)age;
   FIELDREF(fieldvals,"spare1")      = (vector)spare1;
   FIELDREF(fieldvals,"spare2")      = (vector)spare2;
   FIELDREF(fieldvals,"spare3")      = (vector)spare3;
   FIELDREF(fieldvals,"spare4")      = (vector)spare4;
   FIELDREF(fieldvals,"spare5")      = (vector)spare5;
   FIELDREF(fieldvals,"spare6")      = (vector)spare6;

   // Evaluate the shader-generated fields (no evaluation needed)
   // MAINTENANCE: Update this whenever a new shader-generated field is added
   fieldvals[fieldid("speed")] = (vector)speed;
   fieldvals[fieldid("time")]  = (vector)time;

   // Evaluate the shaped fields which are in use
   // MAINTENANCE: Update this whenever the list of field mods is changed
   if(fieldinuse("fmod1",sitevals)) 
      FIELDREF(fieldvals,"fmod1") = evalmodf(fieldvals,FSHAPE_ARGS(mf_,1));
   if(fieldinuse("fmod2",sitevals)) 
      FIELDREF(fieldvals,"fmod2") = evalmodf(fieldvals,FSHAPE_ARGS(mf_,2));
   if(fieldinuse("fmod3",sitevals)) 
      FIELDREF(fieldvals,"fmod3") = evalmodf(fieldvals,FSHAPE_ARGS(mf_,3));
   if(fieldinuse("fmod4",sitevals)) 
      FIELDREF(fieldvals,"fmod4") = evalmodf(fieldvals,FSHAPE_ARGS(mf_,4));
   if(fieldinuse("fmod5",sitevals)) 
      FIELDREF(fieldvals,"fmod5") = evalmodf(fieldvals,FSHAPE_ARGS(mf_,5));
   if(fieldinuse("fmod6",sitevals)) 
      FIELDREF(fieldvals,"fmod6") = evalmodf(fieldvals,FSHAPE_ARGS(mf_,6));

   // Evaluate any noise generator currently in use
   // MAINTENANCE: Update this whenever the list of noise mods is changed
   #define NARGS(serial) Pz,time,dualrest,Prest,Prest2,frame,dr_start,dr_rate, \
                         fieldvals,NOISE_ARGS(mn_,serial)
   if(fieldinuse("nmod1",sitevals)) FIELDREF(fieldvals,"nmod1") = evalmodn(NARGS(1));
   if(fieldinuse("nmod2",sitevals)) FIELDREF(fieldvals,"nmod2") = evalmodn(NARGS(2));
   if(fieldinuse("nmod3",sitevals)) FIELDREF(fieldvals,"nmod3") = evalmodn(NARGS(3));
   if(fieldinuse("nmod4",sitevals)) FIELDREF(fieldvals,"nmod4") = evalmodn(NARGS(4));



   // Smoke
   //----------------------------------------------------------------------
   vector shue   = 1;
   vector salb   = 1;
   float  sndx   = 0;   // density value used for ramp lookups (no scaling)
   float  sden   = max(0,FIELDREF(fieldvals,s_field)[0]);
   vector sphase = set( APPLYMOD(scale,s_phase[0],fieldvals,s_phasemr),
                        APPLYMOD(scale,s_phase[1],fieldvals,s_phasemg),
                        APPLYMOD(scale,s_phase[2],fieldvals,s_phasemb) );
   sphase = clamp(sphase,(vector)1e-6,(vector)1-1e-6);

   if(sden>0) {
      // opacity
      sden   = APPLYMOD(scale,sden,fieldvals,s_fieldm);
      sndx   = max(0,sden);
      sden   = sndx*APPLYMOD(scale,s_fieldk,fieldvals,s_fieldkm);
      Asmoke = 1.0 - exp(-max(0,sden)*dPdz);

      // color
      if(s_enable && !isshadowray()) {
         shue   = (s_usecd) ? s_hue*Cd : s_hue;
         shue   = APPLYRGBMODS(scale,shue,fieldvals,s_huemh,s_huems,"none");
         salb   = shue * APPLYMOD(scale,s_alb,fieldvals,s_albm);

         // Color Correct
         if(s_ccenable)
            salb = cc(salb,s_cchsv,s_cccont,s_ccgamma,s_cctint);

         if(!ispbr) {
            vector cl = 0;
            // Scattering phase not available for PBR
            if(sphase!=VZERO) {
               illuminance(P,{0,0,1},C_PI) {
                  shadow(Cl);
                  // attenuation due to phase (using Henyey-Greenstein)
                  vector kph = minvv(hgphasev(sphase,normalize(L),nV),VONE);
                  // not Mie, and not multi scattering, so roughly approximate
                  // the missing back/fwd scattering with a const scatt of 0.2
                  kph = lerpv((vector)0.2,kph,smoothv(VZERO,(vector)0.3,kph));
                  cl += Cl * kph;
               }
            } else {
               illuminance(P,{0,0,1},C_PI) {
                  shadow(Cl);
                  cl += Cl;
               }
            }
            Csmoke = cl*salb*Asmoke;
         }

      }

   }
   
   // Burn
   //----------------------------------------------------------------------

   #define TEMP_START 400
   float bfield = max(0,FIELDREF(fieldvals,b_tfield)[0]);  // initial burn field
   float bblndf = bfield;                                  // opacity blend weight
   bfield = APPLYMOD(scale,bfield,fieldvals,b_tfieldm);    // current burn field value
   float bamp   = APPLYMOD(scale,b_amp,fieldvals,b_ampm);  // current burn amplitude
   float bmask  = 0;                                       // existence mask for fire
   float balpha = 0;                                       // opacity value for fire
   if((b_enable!=0 || pcwany) && !isshadowray() && bfield>0 && bamp!=0) 
   {
      float btemp   = APPLYMOD(scale,bph_temp,fieldvals,bph_tempm);
      btemp = max(btemp,TEMP_START);                           // temp, kelvin
      float bkcool  = APPLYMOD(scale,bph_kcool,fieldvals,bph_kcoolm);
      bkcool = max(0,bkcool);                                  // red boost
      float bbshift = APPLYMOD(scale,bph_bshift,fieldvals,bph_bshiftm);
      bbshift = max(0,bbshift);                                // blue boost
      // resolve color+intensity according to model
      vector bc = 0; // hue, value depends on model
      float  bk = 0; // intensity, value depends on model
      if(b_model=="physical") { // physical model
         float bbt = fit(max(0,bfield),0,1,TEMP_START,btemp);
         bk = pow(blackbodytmval(bbt),1.0/max(1e-6,1.0+bkcool));

         // color calculation
         if(bbshift>0) {
            float btmid = btemp -  ((btemp-TEMP_START)*.3);
            bbt += lerp(0,bbshift*5000,smooth(btmid,btemp,bbt));
         }
         //float bbscale = blackbodytmcdf(15000) / blackbodytmcdf(btemp);
         float bbscale = bbadjust(TEMP_START,btemp);

         // initial tone-mapped intensity calculation
         bc = blackbodyhue(bbt);
         bk *= bbscale;

         // final amplitude and volume scaling
         bk *= dPdz * bamp;

      } else {                            // artistic model
         bc = evalrampc(bfield,RAMPC_ARGS(ba,_,c));
         bk = evalrampf(bfield,RAMP_ARGS(ba,_,k));
         bk *= bamp * dPdz;
      }
      if(b_usecd) bc*=Cd;
      Cfire = bc*bk;
      Afire = 0;     // by default, fire has zero density

      // soft-clip the final color for the physical model
      if(b_model=="physical" && bph_tksoft && bph_ksoftk>0 && bfield>bph_ksofte) 
         Cfire = softclipv(Cfire/dPdz,bph_ksofte,bph_ksoftk)*dPdz;

      // If we're visibly hot, then blend to new opacity within burn, 
      // according to heat, and override burn density with field if requested
      float bblend = APPLYMOD(scale,b_blend,fieldvals,b_blendm);
      //bmask  = smooth(1,2,bk/dPdz);
      bmask  = smooth(1,10,bk/dPdz);
      balpha = bmask * smooth(0,1.0/max(1e-6,bblend),bblndf);
      if(balpha>0) {
         float bden = bfield; // default, this field
         // eval burn density field, if any
         if(b_dfield!="none" && bblend>0) {
            bden = FIELDREF(fieldvals,b_dfield)[0];
            bden = APPLYMOD(scale,bden,fieldvals,b_dfieldm);
         }

         // Apply burn density scale
         float bkden = APPLYMOD(scale,b_kdens,fieldvals,b_kdensm);
         bden  = max(0,bden*bkden);

         Afire  = 1.0 - exp(-bden*balpha*dPdz);
      }

      Asmoke = lerp(Asmoke,0,bmask);
      Mfire  = 1.0 - exp(-bmask*dPdz);

      // Color Correct
      if(b_ccenable)
         Cfire = cc(Cfire,b_cchsv,b_cccont,b_ccgamma,b_cctint);
   }
   
   // Scattering
   //----------------------------------------------------------------------
   if(ss_enable && !isshadowray() && ss_pcsmoke!="" && ss_pcfire!="" &&
      ss_amp!=0 && !pcwany && Asmoke>0 && bmask<1.0) 
   {
      //int maxfail = (int)1e+6; //ceil(0.05*(float)ss_isamps);
      int maxfail = (int)ceil(0.2*(float)ss_isamps);
      Escatt = pc_ssvol(ss_pcsmoke,ss_pcfire,"Cfire",getblurP(0),nV,Asmoke,
                        ss_rad,ss_isamps,ss_fsamps,maxfail,
                        ss_attdens,ss_attdist,ss_shtype,0.01,ss_phase);

      // Color Correct
      if(ss_ccenable)
         Escatt = cc(Escatt,ss_cchsv,ss_cccont,ss_ccgamma,ss_cctint);

      Escatt *= ss_amp*Asmoke;//*dPdz;
   }


   // Output
   //----------------------------------------------------------------------
   // Shadow Rays
   if(isshadowray()) {
      if(pcwany) {
         Of = 0;
      } else {
         vector sshcol = s_shadh;
         sshcol = APPLYRGBMODS(scale,sshcol,fieldvals,s_shadhmh,s_shadhms,"none");
         float  sshval = s_shadk;
         sshval = APPLYMOD(scale,sshval,fieldvals,s_shadkm);
         Of = (vector)Asmoke * maxfv(0,col2opac(sshcol)*sshval);

         // Weigh opacity in inverse proportion to the scattering assymetry
         // to emulate in-scattering when computing shadows (non-pbr)
         if(!ispbr) Of /= maxfv(0.1,hgphasev(sphase,nV,-nV)); 
      }
   // Writing Point Clouds
   } else if(pcwany) {
      if(pcwsmoke && Asmoke*(1.-bmask)>0) pc_writesmoke(ss_pcsmoke,Asmoke);
      if(pcwfire && bmask>0) pc_writefire(ss_pcfire,"Cfire",Cfire);
      Cf = Asmoke*pcwsmoke + Afire*pcwfire; 
      Of = 0; 
      F  = 0;
   // Normal Output
   } else {
      Of = (Asmoke*s_enable) + (Afire*b_enable);
      Cf = (Csmoke*s_enable) + (Cfire*b_enable) + (Escatt*ss_enable);
      F  = isotropic()*salb;
      Ce = Cfire + Escatt;
   }

}
